AWSTemplateFormatVersion: "2010-09-09"
Description: SQS POC CHRIS (queue + DLQ + queue policy)

Parameters:
  EnvironmentPrefix:
    Type: String
    Default: poc-christopher
  MessageRetentionSeconds:
    Type: Number
    Default: 345600 # 4 dias
  VisibilityTimeout:
    Type: Number
    Default: 30
  DelaySeconds:
    Type: Number
    Default: 0
  MaxReceiveCount:
    Type: Number
    Default: 5
  AllowedPrincipalArn:
    Type: String
    Description: ARN do principal (usuário/role) que poderá usar a fila
    # Ex.: arn:aws:iam::602359230095:user/ChristopherLambert
    Default: arn:aws:iam::602359230095:user/ChristopherLambert
  # --------------------- Parametros POSTGREEDB --------------------------------------
  AllowedCidr:
    Type: String
    Default: 0.0.0.0/0
    Description: "CIDR permitido na porta 5432 (exemplo: SEU_IP/32)"
  DBInstanceClass:
    Type: String
    Default: db.t3.micro        # comum em todas regiões
    AllowedPattern: "db\\..+"
    Description: Classe da instância

Resources:
  PocDlq:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "${EnvironmentPrefix}sqs-dlq"

  PocQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "${EnvironmentPrefix}sqs"
      DelaySeconds: !Ref DelaySeconds
      VisibilityTimeout: !Ref VisibilityTimeout
      MessageRetentionPeriod: !Ref MessageRetentionSeconds
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt PocDlq.Arn
        maxReceiveCount: !Ref MaxReceiveCount

  # ----> Policy da fila principal (autoriza o principal indicado)
  PocQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref PocQueue
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          # Pub + Consume básicos na fila principal
          - Sid: AllowPrincipalUseMainQueue
            Effect: Allow
            Principal:
              AWS: !Ref AllowedPrincipalArn
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:ChangeMessageVisibility
              - sqs:GetQueueAttributes
              - sqs:GetQueueUrl
            Resource: !GetAtt PocQueue.Arn

  # (OPCIONAL) Policy para permitir ler/apagar da DLQ (útil para troubleshooting)
  PocDlqPolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref PocDlq
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowPrincipalUseDlq
            Effect: Allow
            Principal:
              AWS: !Ref AllowedPrincipalArn
            Action:
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
              - sqs:GetQueueUrl
            Resource: !GetAtt PocDlq.Arn

  # -------------------- DynamoDB --------------------
  PocTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${EnvironmentPrefix}sqs-messages"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: MessageId
          AttributeType: S
      KeySchema:
        - AttributeName: MessageId
          KeyType: HASH
      SSESpecification:
        SSEEnabled: true

  # -------------------- RDS Postgree --------------------
  PostgresSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Acesso ao Postgres (POC)"
      VpcId: vpc-f671b78c
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          CidrIp: !Ref AllowedCidr

  PostgresInstance:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Delete            # POC: apaga sem snapshot
    UpdateReplacePolicy: Delete
    Properties:
      DBInstanceIdentifier: !Sub "${EnvironmentPrefix}-pg-poc"
      Engine: postgres
      EngineVersion: "16"
      DBInstanceClass: !Ref DBInstanceClass
      AllocatedStorage: 20
      StorageType: gp3
      PubliclyAccessible: true        # POC: acesso direto do notebook
      MultiAZ: false
      Port: 5432
      DBName: appdb
      MasterUsername: Christopher
      MasterUserPassword: Sunrise2512
      BackupRetentionPeriod: 0        # sem backup (POC)
      VPCSecurityGroups:
        - !GetAtt PostgresSG.GroupId
      # O RDS não aceita DB Subnet Group com só uma subnet. Ele exige mínimo 2 subnets em AZs diferentes da mesma VPC.
      # DB Subnet Gruop deve ser RDS e não DAX(DynamoDB) 
      # Qualquer um dos dois erros acima vai dizer que não encontrou 
      DBSubnetGroupName: rdssubnetvirginia 
      StorageEncrypted: false         # POC: simplificado (ligue em prod)

  # -------------------- Lambda Role --------------------
  PocLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${EnvironmentPrefix}sqs-to-ddb-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole # logs em CloudWatch
      Policies:
        - PolicyName: AllowDdbPut
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt PocTable.Arn
        - PolicyName: AllowSqsConsume
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:GetQueueUrl
                  - sqs:ChangeMessageVisibility
                Resource: !GetAtt PocQueue.Arn

  # -------------------- Lambda Function / NODE.JS --------------------
  PocSqsToDdbFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${EnvironmentPrefix}-sqs-to-ddb"
      Runtime: nodejs20.x
      Handler: index.handler
      MemorySize: 256
      Timeout: 30
      Role: !GetAtt PocLambdaRole.Arn
      Environment:
        Variables:
          TABLE_NAME: !Ref PocTable
      Code:
       ZipFile: |
          const { DynamoDBClient, PutItemCommand } = require("@aws-sdk/client-dynamodb");
          const client = new DynamoDBClient();

          exports.handler = async (event) => {
            const table = process.env.TABLE_NAME;

            const puts = event.Records.map(async (rec) => {
              const body = rec.body ?? "";
              const sentTs = rec.attributes && rec.attributes.SentTimestamp
                ? new Date(Number(rec.attributes.SentTimestamp)).toISOString()
                : new Date().toISOString();

              // Converte MessageAttributes da SQS para AttributeValue do DynamoDB
              const attrs = rec.messageAttributes || {};
              const attrMap = {};
              for (const [key, val] of Object.entries(attrs)) {
                if (val.stringValue != null) {
                  attrMap[key] = { S: String(val.stringValue) };
                } else if (val.binaryValue != null) {
                  // binaryValue vem base64 da SQS; armazena como B no DDB
                  attrMap[key] = { B: Buffer.from(val.binaryValue, "base64") };
                } else if (Array.isArray(val.stringListValues) && val.stringListValues.length) {
                  attrMap[key] = { L: val.stringListValues.map(s => ({ S: s })) };
                }
              }

              const item = {
                MessageId:          { S: rec.messageId },
                Body:               { S: body },
                Attributes:         { M: attrMap },
                SentTimestamp:      { S: sentTs },
                ApproxReceiveCount: { N: String(rec.attributes?.ApproximateReceiveCount ?? "1") },
                ReceivedAt:         { S: new Date().toISOString() }
              };

              await client.send(new PutItemCommand({
                TableName: table,
                Item: item
              }));
            });

            await Promise.all(puts);
            return { statusCode: 200 };
          };

  # -------------------- Event Source Mapping (SQS -> Lambda) --------------------
  PocQueueToLambdaMapping:
    Type: AWS::Lambda::EventSourceMapping
    DependsOn:
      - PocSqsToDdbFunction
      - PocQueue
    Properties:
      EventSourceArn: !GetAtt PocQueue.Arn
      FunctionName: !Ref PocSqsToDdbFunction
      Enabled: true
      BatchSize: 10
      MaximumBatchingWindowInSeconds: 5
      # opcional: VisibilityTimeout da fila já cobre; pode-se usar MaximumRetryAttempts etc.

Outputs:
  DbEndpoint:
    Description: Endpoint do RDS
    Value: !GetAtt PostgresInstance.Endpoint.Address
  DbPort:
    Description: Porta
    Value: !GetAtt PostgresInstance.Endpoint.Port
  DbName:
    Description: Nome do DB inicial
    Value: appdb
  ConnString:
    Description: String de conexão (psql)
    Value: !Sub "psql -h ${PostgresInstance.Endpoint.Address} -p 5432 -U Christopher -d appdb"
  QueueUrl:
    Value: !Ref PocQueue
  DlqUrl:
    Value: !Ref PocDlq
  QueueArn:
    Value: !GetAtt PocQueue.Arn
  DlqArn:
    Value: !GetAtt PocDlq.Arn
  TableName:
    Value: !Ref PocTable
  LambdaName:
    Value: !Ref PocSqsToDdbFunction
